#pragma once

#include "gsl/assert"
#include "asl/types"
#include <type_traits>
#include <utility>
#include "asl/meta"

namespace gsl
{
    struct null_span { };


    template <typename T>
    class span
    {
    public:
        using value_type = T;

        constexpr span(null_span)
            : m_ptr(nullptr)
            , m_size(0)
            , m_sanityCheck(false)
        {
        }

        constexpr span()
            : m_ptr(nullptr)
            , m_size(0)
            , m_sanityCheck(false)
        { }

        template <typename Container, std::enable_if_t<!std::is_same_v<Container, span>>>
        constexpr span(Container& container) noexcept
            : m_ptr(container.data())
            , m_size(container.size())
        {
            sanity_check();
        }

        template <typename Container, std::enable_if_t<!std::is_same_v<Container, span>>>
        constexpr span(const Container& container) noexcept
            : m_ptr(container.data())
            , m_size(container.size())
        {
            sanity_check();
        }

        constexpr span(T* begin, T* end) noexcept
            : m_ptr(begin)
            , m_size(end - begin)
        {
            sanity_check();
        }

        constexpr span(T* ptr, asl::sizei size) noexcept
            : m_ptr(ptr)
            , m_size(size)
        {
            sanity_check();
        }

        template <asl::sizei N>
        constexpr span(T (&arr)[N]) noexcept
            : m_ptr(arr)
            , m_size(N)
        {
            sanity_check();
        }

        constexpr span(const span& oth) noexcept
            : m_ptr(oth.m_ptr)
            , m_size(oth.m_size)
            , m_sanityCheck(oth.m_sanityCheck)
        { }

        constexpr span& operator=(const span& oth) noexcept
        {
            m_ptr = oth.m_ptr;
            m_size = oth.m_size;
            m_sanityCheck = oth.m_sanityCheck;

            sanity_check();

            return *this;
        }

        constexpr span(span&& oth) noexcept
            : m_ptr(std::exchange(oth.m_ptr, nullptr))
            , m_size(std::exchange(oth.m_size, 0))
            , m_sanityCheck(std::exchange(oth.m_sanityCheck, false))
        {
            sanity_check();
        }

        constexpr span& operator=(span&& oth) noexcept
        {
            m_ptr = std::exchange(oth.m_ptr, nullptr);
            m_size = std::exchange(oth.m_size, 0);
            m_sanityCheck = std::exchange(oth.m_sanityCheck, false);

            sanity_check();

            return *this;
        }

        constexpr asl::sizei size() const noexcept
        {
            sanity_check();
            return m_size;
        }

        constexpr bool empty() const noexcept
        {
            return m_size == 0;
        }

        constexpr T* get() noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr const T* get() const noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr T* begin() noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr T* end() noexcept
        {
            sanity_check();
            return m_ptr + m_size;
        }

        constexpr const T* begin() const noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr const T* end() const noexcept
        {
            sanity_check();
            return m_ptr + m_size;
        }

        constexpr T& at(asl::sizei index) noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr const T& at(asl::sizei index) const noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr T& operator[](asl::sizei index) noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr const T& operator[](asl::sizei index) const noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr T* data() const noexcept
        {
            return m_ptr;
        }

        constexpr span subspan(asl::sizei start, asl::sizei end = asl::sizei(-1)) const noexcept
        {
            if (end == asl::sizei(-1))
            {
                end = m_size;
            }

            Ensures(start >= 0 && start < m_size && end <= m_size, "[gsl/span] Invalid subspan range!");
            return span{ m_ptr + start, end - start };
        }

    private:

        constexpr void sanity_check() const noexcept 
        {
            if (m_sanityCheck)
            {
                Ensures(m_ptr != nullptr && m_size > 0, "[gsl/span] Container should point to something!");
            }
        }

        T* m_ptr;
        asl::sizei m_size;
        bool m_sanityCheck{true};
    };

    template <typename Container>
    auto make_span(const Container& t)
    {
        return gsl::span<typename Container::value_type>{t};
    }

    template <typename Container>
    auto make_const_span(const Container& t)
    {
        return gsl::span<const typename Container::value_type>{t};
    }

} // namespace gsl

// vim: ft=cpp
