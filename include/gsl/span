#pragma once

#include "gsl/assert"
#include "asl/types"
#include <type_traits>
#include <utility>

namespace gsl
{
    template <typename T>
    class span
    {
    public:
        using value_type = T;

        constexpr span() noexcept
            : m_ptr(nullptr)
            , m_size(0)
        {
            // This will default construct with null.
            // help me
        }

        template <typename Container>
        constexpr span(Container& container) noexcept
            : m_ptr(container.data())
            , m_size(container.size())
        {
            sanity_check();
        }

        template <typename Container>
        constexpr span(const Container& container) noexcept
            : m_ptr(container.data())
            , m_size(container.size())
        {
            sanity_check();
        }

        constexpr span(T* begin, T* end) noexcept
            : m_ptr(begin)
            , m_size(end - begin)
        {
            sanity_check();
        }

        constexpr span(T* ptr, asl::sizei size) noexcept
            : m_ptr(ptr)
            , m_size(size)
        {
            sanity_check();
        }

        template <asl::sizei N>
        constexpr span(T (&arr)[N]) noexcept
            : m_ptr(arr)
            , m_size(N)
        {
            sanity_check();
        }

        constexpr span(const span& oth) noexcept = default;
        constexpr span& operator=(const span& rhs) noexcept = default;

        constexpr span(span&& oth) noexcept
            : m_ptr(std::exchange(oth.m_ptr, nullptr))
            , m_size(std::exchange(oth.m_size, 0))
        {
            sanity_check();
        }

        constexpr span& operator=(span&& oth) noexcept
        {
            m_ptr = std::exchange(oth.m_ptr, nullptr);
            m_size = std::exchange(oth.m_size, 0);

            sanity_check();

            return *this;
        }

        /*
        template <typename U, std::enable_if_t<!std::is_same<U, T>::value>>
        span(const span<U>& oth)
        {
            static_assert(std::is_same<U, T>::value, "The types are not the same");
            static_assert(!std::is_convertible<U*, T*>::value,
                        "There is an implicit conversion going on");
        }

        template <typename U, std::enable_if_t<!std::is_same<U, T>::value>>
        span& operator=(const span<U>& oth)
        {
            static_assert(std::is_same<U, T>::value, "The types are not the same");
            static_assert(!std::is_convertible<U*, T*>::value,
                        "There is an implicit conversion going on");
        }

        template <typename U, class = std::enable_if_t<!std::is_same<U, T>::value>>
        span(U* arr, asl::sizei size)
        {
            static_assert(std::is_same<U, T>::value, "The types are not the same");
            static_assert(!std::is_convertible<U*, T*>::value || std::is_same<T, U>::value,
                        "There is an implicit conversion going on");
        }

        template <typename U, asl::sizei N, class = std::enable_if_t<!std::is_same<U, T>::value>>
        span(U (&arr)[N])
        {
            static_assert(std::is_same<U, T>::value, "The types are not the same");
            static_assert(!std::is_convertible<U*, T*>::value || std::is_same<T, U>::value,
                        "There is an implicit conversion going on");
        }

        template <typename U, asl::sizei N, class = std::enable_if_t<!std::is_same<U, T>::value>>
        span& operator=(U (&arr)[N])
        {
            static_assert(std::is_same<U, T>::value, "The types are not the same");
            static_assert(!std::is_convertible<U*, T*>::value || std::is_same<T, U>::value,
                        "There is an implicit conversion going on");
        }
        */

        constexpr asl::sizei size() const noexcept
        {
            sanity_check();
            return m_size;
        }

        constexpr T* get() noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr const T* get() const noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr T* begin() noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr T* end() noexcept
        {
            sanity_check();
            return m_ptr + m_size;
        }

        constexpr const T* begin() const noexcept
        {
            sanity_check();
            return m_ptr;
        }

        constexpr const T* end() const noexcept
        {
            sanity_check();
            return m_ptr + m_size;
        }

        constexpr T& at(asl::sizei index) noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr const T& at(asl::sizei index) const noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr T& operator[](asl::sizei index) noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

        constexpr const T& operator[](asl::sizei index) const noexcept
        {
            Expects(index < m_size, "[gsl/span] Index out of bounds");
            sanity_check();
            return *(m_ptr + index);
        }

    private:

        constexpr void sanity_check() const noexcept 
        {
            Ensures(m_ptr != nullptr && m_size > 0, "[gsl/span] Container should point to something!");
        }

        T* m_ptr;
        asl::sizei m_size;
    };

    template <typename Container>
    auto make_span(const Container& t)
    {
        return gsl::span<typename Container::value_type>{t};
    }

    template <typename Container>
    auto make_const_span(const Container& t)
    {
        return gsl::span<const typename Container::value_type>{t};
    }

} // namespace gsl

// vim: ft=cpp
